page.title = Strnigtree JSON

<h2>Stringtree JSON</h2>

<p>Stringtree JSON is a small, neat and robust Java implementation of a reader, writer, and
validator for the <a href='http://www.json.org/'>JSON (JavaScript Object Notation) data format</a>. The <a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONReader.java'>reader</a>
and <a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONWriter.java'>writer</a>
are one class each, with no dependencies at all. Even the <a href='https://sourceforge.net/project/showfiles.php?group_id=80689&package_id=226281&release_id=496375'>full stringtree JSON jar</a> with reader, writer,
validator and some other useful classes weighs in at just 13kB!</p>

<p>This project was started when I was looking for an alternative to bloated and clumsy SOAP web services for a simple remote procedure
call (RPC) interface to connect two Java applications. I looked around the internet but the only Java implementations I found at the
time seemed huge (hundreds or even thousands of lines of code) and required the inclusion of other large jar files in order to use them.
At that point I resolved to write my own implementation which would exactly match the <a href='http://www.json.org/'>JSON spec</a> and have
absolutely no external dependencies. This project is the result</p>

<h2>What can I use it for?</h2>

<p>JSON is a concise and largely human-readable representation of a wide range of structured data.
Data stored or transferred as JSON can be read and written by code in a wide range of programming
languages. Example uses include:</p>

<ul>
<li>Transferring data between a server application and a JavaScript (AJAX) client.</li>
<li>A "lingua franca" for communicating rich data with applications in other languages.</li>
<li>An alternative to XML for some inter-application data transfers.</li>
<li>An alternative to XML or "properties" files for application configuration.</li>
<li>An alternative to SOAP for simple remote procedure call (RPC) applications.</li>
<li>Storing object data in a relational database.</li>
</ul>

<p>And many more possibilities...</p>

<h2>What does Stringtree JSON include?</h2>

<p>The Stringtree JSON components consist of three key classes, referred to sometimes as the JSON trilogy:</p>

<ul>

<li><a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONReader.java'>JSONReader.java</a> </li>
<li><a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONWriter.java'>JSONWriter.java</a> </li>
<li><a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONValidator.java'>JSONValidator.java</a> </li>

</ul>

<p>JSONReader and JSONWriter can be used completely stand-alone. If your data is being automatically generated and you already know
that it is valid, that's all you need.</p>

<p>If you are not so sure about the validity of the JSON text your application may
receive, or are worried about the validity of JSON generated by your application, you can use the JSONValidator. When the
JSONValidator runs, it needs some way of displaying any errors it encounters. To allow maximum flexibility, it accepts an object which
implements the <a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONErrorListener.java'>JSONErrorListener</a>
interface. A few example implementations are provided for convenience:</p>

<ul>

<li><a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/BufferErrorListener.java'>BufferErrorListener.java</a> catches error reports in a StringBuffer for processing later.</li>
<li><a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/ExceptionErrorListener.java'>ExceptionErrorListener.java</a> throws an IllegalArgumentException with the error report as the message.</li>
<li><a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/StdoutStreamErrorListener.java'>StdoutStreamErrorListener.java</a> writes error reports to the standard output stream.</li>

</ul>

<p>Two convenience classes are also provided to simplify the case where you always want to validate:</p>

<ul>

<li><a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONValidatingReader.java'>JSONValidatingReader.java</a> extends JSONReader and always validates its output after generation.</li>
<li><a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONValidatingWriter.java'>JSONValidatingWriter.java</a> extends JSONWriter and always validates its input before processing.</li>

</ul>

<h2>How do I use Stringtree JSON?</h2>

<p>I'll give a few simple examples here to get you started, but I strongly recommend checking out the <a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/test/java/tests/json/'>Stringtree JSON unit test suite</a>
for a deeper understanding of what is possible and what to expect. Stringtree JSON was developed using <a href='http://en.wikipedia.org/wiki/Test_driven_development'>Test-Driven Development</a>, so the tests exercise every facility
of the software.</p>

<h3>JSONReader examples</h3>

<p>First a very simple example. The text string "true" is valid JSON, and (naturally enough) represents the boolean value TRUE.
To show that the JSONReader works, just grab the <a href='https://svn.sourceforge.net/svnroot/stringtree/trunk/src/delivery/java/org/stringtree/json/JSONReader.java'>source file</a> from subversion, or include stringtree-json.jar,
stringtree.jar or mojasef.jar in your classpath. Then you can do stuff like:</p>

<div class='code'><pre>
import org.stringtree.json.JSONReader;

class JSONReaderExample {
  JSONReader reader = new JSONReader();

  public void example() {
    Object result = reader.read("true");
    System.out.println("JSONReader result is " + result +
      " of class " + result.getClass());
  }
}
</pre></div>

<p>In many ways that's all there is to it. Just pass in a text string containing some JSON,
and the reader will return a Java object resulting from parsing the JSON. All that varies
is the type of the returned object.</p>

<ul>
<li>A JSON "array" is returned as a Java Collection object, currently an ArrayList.</li>
<li>A JSON "object" is returned as a Java Map object, currently a HashMap.</li>
<li>A JSON "number" is returned as a Java Number object, currently Long, BigInteger, Double or BigDecimal.</li>
<li>A JSON "string" is returned as a Java String object.</li>
<li>A JSON "true" or "false" is returned as a Java Boolean object.</li>
<li>A JSON "null" is returned as a Java null.</li>
</ul>

<p>Within a JSON "object" or "array", each element also follows the above rules, so (for example) the
JSON string</p>

<ul><tt>[ 123, "hello", true, null ]</tt></ul>

<p>would be returned as an ArrayList with four entries.
The first entry would be a Long, the second a String, the third a Boolean, and the fourth would be null.

<p>Using the JSONValidatingReader is very similar. If you are happy to use the default ErrorListener
(which writes its error log to the standard output stream), then usage is identical to the non-validating reader:</p>

<div class='code'><pre>
import org.stringtree.json.JSONValidatingReader;

class JSONValidatingReaderExample {
  JSONReader reader = new JSONValidatingReader();

  public void example() {
    Object result = reader.read("true");
    System.out.println("JSONReader result is " + result +
      " of class " + result.getClass());
  }
}
</pre></div>

<p>The only difference to be aware of is that the JSONVallidatingReader returns a special object
(<i>JSONValidatingReader.INVALID</i>) if the JSON text is not valid.</p>

<p>To specify a different ErrorListener, just pass it in to the JSONValidatingReader constructor:</p>

<div class='code'><pre>
import org.stringtree.json.JSONValidatingReader;

class JSONValidatingReaderExample {
  JSONReader reader = new JSONValidatingReader(
    new ExceptionErrorListener());

  public void example() {
    Object result = reader.read("true");
    System.out.println("JSONReader result is " + result +
      " of class " + result.getClass());
  }
}
</pre></div>


<h3>JSONWriter examples</h3>

<p>To start the JSONWriter examples, let's show the converse of the first JSONReader example:</p>

<div class='code'><pre>
import org.stringtree.json.JSONWriter;

class JSONWriterExample {
  JSONWriter writer = new JSONWriter();

  public void example() {
    System.out.println("JSONWriter result is " + writer.write(true));
  }
}
</pre></div>

<p>Avoiding surprises when using the JSONWriter is a little more tricky than with the JSONReader.
Java has a much richer type structure than JSON, so any conversion from Java to JSON is bound to
include some limitations. Stringtree JSON tries to convert as intelligently as it can, by applying
the following sequence of rules:</p>

<ol>
<li>If the Java object is null, generate a JSON <tt>null</tt>.</li>
<li>If the Java object is a Boolean, generate a JSON <tt>true</tt> or <tt>false</tt>.</li>
<li>If the Java object is a Number (such as an Integer, Double, etc), generate a JSON "number".</li>
<li>If the Java object is a String or a single character, generate a JSON "string"</li>
<li>If the Java object is a Map, generate a JSON "object" with the Map entries as elements.</li>
<li>If the Java object is an array, an iterator, or an iterable collection, generate a JSON "array"</li>
<li>Otherwise, treat the supplied object as a JavaBean, and generate a JSON "object" with the bean properties as elements.</li>
</ol>

<p>One important consideration is that of cyclic references. In Java it is quite feasible for objects
to refer to each other in a cyclic manner. For example, object a refers to object b, which in turn refers
to object c, which refers back to object a. JSON has no support for such cyclic references, so the JSONWriter
is unable to write them. Whenever the JSONWriter detects that an object element or property refers to an object
which has already been written, it will generate a JSON <tt>null</tt>. If your application requires that such
cyclic relationships are preserved, then JSON is probably not a good data format to use.</p>

<p>One more consideration is that of whether the class name of a JavaBean should be treated as a property and
generated as an element in the resulting JSON text. All Java objects provide a <tt>getClass()</tt> method, which
implies that all JavaBeans provide a readable "class" property. By default, the JSONWriter will include this
class name as an element whenever it generates a JSON "object" from a JavaBean. You can switch off this behaviour
by supplying a boolean false parameter to the JSONWriter constructor.</p>

<p>Using the JSONValidatingWriter is very similar. If you are happy to use the default ErrorListener
(which writes its error log to the standard output stream), then usage is identical to the non-validating writer:</p>

<div class='code'><pre>
import org.stringtree.json.JSONValidatingWriter;

class JSONValidatingWriterExample {
  JSONReader reader = new JSONValidatingWriter();

  public void example() {
    System.out.println("JSONWriter result is " + writer.write(true));
  }
}
</pre></div>

<p>To specify a different ErrorListener, just pass it in to the JSONValidatingWriter constructor:</p>

<div class='code'><pre>
import org.stringtree.json.JSONValidatingWriter;

class JSONValidatingWriterExample {
  JSONReader reader = new JSONValidatingWriter(
    new ExceptionErrorListener());

  public void example() {
    System.out.println("JSONWriter result is " + writer.write(true));
  }
}
</pre></div>

<p>To override the default bean class name behaviour as well as specifying a different ErrorListener,
pass the ErrorListener first, followed by the boolean:</p>

<div class='code'><pre>
import org.stringtree.json.JSONValidatingWriter;

class JSONValidatingWriterExample {
  JSONReader reader = new JSONValidatingWriter(
    new ExceptionErrorListener(), false);

  public void example() {
    System.out.println("JSONWriter result is " + writer.write(true));
  }
}
</pre></div>


<h2>Does anyone actually use Stringtree JSON?</h2>

<p>Stringtree JSON is used in at least one commercial application, and a slightly-modified version is included in
<a href='http://cwiki.apache.org/S2PLUGINS/json-plugin.html'>a JSON plugin</a> for the <a href='http://struts.apache.org/2.x/'>Struts 2</a> open source project
(source code available from <a href='http://jsonplugin.googlecode.com/svn/trunk/src/main/java/com/googlecode/jsonplugin/'>Google Code</a>.)</p>

<p>If you or your project are using Stringtree JSON, and don't mind being listed here, please let me know and
I'll add a name check and a link to your project web site.</p>

<h2>Where can I find out more?</h2>

<p>The full Stringtree source code (including JSON) and jar files are available from <a href='http://sourceforge.net/projects/stringtree'>Sourceforge</a>.
There is also an occasional <a href='http://blog.stringtree.org/'>blog about Stringtree development</a>, or <a href='http://blog.stringtree.org/category/projects/json/'>just the posts about JSON</a>.</p>

<p>The definitive web site about JSON is at <a href='http://www.json.org/'>www.json.org</a>. There you can find a growing list of JSON implementations in a wide variety of languages and styles.</p>

<h2>Who wrote this stuff, anyway?</h2>

<p>The original code was written by <a href='http://www.efsol.com/FrankCarver.html'>Frank Carver</a>. Suggestions, patches and bug reports gratefully recieved from:</p>

<ul>
<li><a href='http://faq.javaranch.com/view?ActiveStaff#jimyingst'>Jim Yingst</a></li>
<li><a href='http://www.manniwood.com/'>Manni Wood</a>
<li><a href='http://sonnygill.wordpress.com/'>Sonny Gill</a>
<li><a href='http://sandbox.clint.pells.us/'>Clint Pells</a></li>
<li>"Chris"</li>
<li>"jlist"</li>
</ul>
